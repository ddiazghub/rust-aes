use aes::{*, aes128::Key128, aes192::Key192, aes256::Key256};

pub fn main() {
    exercise3();
}

fn exercise1() {
    let mut keys: [[u8; 16]; 11] = Default::default();

    let a8 = [
        0x20, 0x24, 0x7a, 0x24,
        0xc2, 0x2c, 0x1a, 0xc1,
        0x2f, 0x75, 0x76, 0xa0,
        0x32, 0xe3, 0xe1, 0x75,
    ];

    keys[7] = [
        0x56, 0xf1, 0x84, 0x8b,
        0x75, 0xad, 0xbb, 0xbe,
        0x14, 0x58, 0xc6, 0x87,
        0x76, 0x4a, 0x9c, 0xe4,
    ];

    keys[8] = [
        0x1d, 0x5c, 0x6b, 0xf7,
        0xab, 0xe2, 0x77, 0xd8,
        0xc3, 0xbd, 0x10, 0x80,
        0xa7, 0x71, 0xba, 0xea,
    ];

    keys[9] = [
        0x51, 0x28, 0x2e, 0x54,
        0xa3, 0x5e, 0xa2, 0x0f,
        0xc7, 0xce, 0x5d, 0x0b,
        0x40, 0xd0, 0x72, 0x35,
    ];

    let aes = AES128::with_keys(keys, Mode::ECB);
    let a9 = aes.round(a8, 7);
    let a10 = aes.round(a9, 8);
    let out = aes.partial_round(a10, 9);

    println!("A8 = {a8:x?}");
    println!("");
    println!("A9 = {a9:x?}");
    println!("A10 = {a10:x?}");
    println!("A11 = {out:x?}");
}

fn exam1() {
    let key: Key256 = [
        0x1c, 0x43, 0x3e, 0x71,
        0x15, 0x84, 0x3e, 0xab,
        0x4a, 0x20, 0xd4, 0x45,
        0xcb, 0xe6, 0x47, 0x68,
        0x08, 0x81, 0xcb, 0x07,
        0x7f, 0xc5, 0x03, 0x72,
        0xc2, 0xd7, 0x54, 0xae,
        0x61, 0x06, 0xdd, 0x8f,
    ];

    let aes = AES256::new(key, Mode::ECB);
    
    for (i, key) in aes.keys().into_iter().enumerate() {
        println!("k{i} = {}", hex::encode(key));
    }
}

fn exercise2() {
    let key: Key256 = [
        0x1c, 0x43, 0x3e, 0x71,
        0x15, 0x84, 0x3e, 0xab,
        0x4a, 0x20, 0xd4, 0x45,
        0xcb, 0xe6, 0x47, 0x68,
        0x08, 0x81, 0xcb, 0x07,
        0x7f, 0xc5, 0x03, 0x72,
        0xc2, 0xd7, 0x54, 0xae,
        0x61, 0x06, 0xdd, 0x8f,
    ];

    let aes = AES256::new(key, Mode::ECB);
    
    let messages = [
        "4fc86c3764d13f5dbe2e89090fc49581",
        "173c0b3879620ef70731c55eb4f26a2a",
        "9a022558563774b7f461cfb72f196d78",
        "b26e04d63ce379ee94a46b888af7c2ee",
        "75af92cebbe06eb63b0b2bc2d0d86864",
    ];

    for (i, message) in messages.into_iter().enumerate() {
        let i = i + 1;
        let message = hex::decode(message).unwrap();
        println!("Message {i}:");
        let ciphertext = aes.encrypt_block(message.try_into().unwrap());
        println!("Ciphertext {i}: {}", hex::encode(&ciphertext));
        println!("");
    }
}

fn exercise3() {
    let ciphertext = hex::decode("8502e9f8a080cd7f0d57f157cf82ccb5").unwrap();

    let key: Key256 = [
        0x1c, 0x43, 0x3e, 0x71,
        0x15, 0x84, 0x3e, 0xab,
        0x4a, 0x20, 0xd4, 0x45,
        0xcb, 0xe6, 0x47, 0x68,
        0x08, 0x81, 0xcb, 0x07,
        0x7f, 0xc5, 0x03, 0x72,
        0xc2, 0xd7, 0x54, 0xae,
        0x61, 0x06, 0xdd, 0x8f,
    ];

    let aes = AES256::new(key, Mode::ECB);
    let message = aes.decrypt_block(ciphertext.try_into().unwrap());
    println!("Ciphertext: {}", hex::encode(&message));
}
